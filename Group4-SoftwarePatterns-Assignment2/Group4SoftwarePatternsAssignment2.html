<!DOCTYPE html>
<html lang="en-us">
<head>
    <title>Group 4 - Software Patterns - Assignment 2</title>
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700italic,400italic,700' rel='stylesheet' type='text/css' />
    <link rel="stylesheet" type="text/css" href="font-choice.css" />
    <link rel="stylesheet" type="text/css" href="report-style.css" />
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
</head>
<body>
    <div class="margincontainer">
        <article class="textcontainer" id="outer_root">
            <header class="titlepage">
                <hgroup>
                    <h1>Mercurial </h1>
                    <h2>
                        <img class="center" width="400" height="200" src="images/droplets.png" style="max-width: 50%; height: auto;" alt="Mercurial SCM Icon" />
                    </h2>
                    <h2>Software Patterns</h2>
                    <h2>Assignment 2</h2>
                    <h2>Group 4</h2>
                    <h2>Version 3</h2>
                </hgroup>
                <div class="authorsbox">
                    <div>Divya Avalur</div>
                    <div>Assel Bekbatyrova</div>
                    <div>Eamon Nerbonne</div>
                    <div>Sunna Björg Sigurjónsdóttir</div>
                    <div>Edy Suharto</div>
                </div>
            </header>
            <!-- Revision history page -->
            <nav>
                <h1>Contents </h1>
                <div class="generateTableOfContents"></div>
            </nav>
            <aside>
                <h1>Revision history </h1>
                <table class="bookstyleborders">
                    <tbody>
                        <tr>
                            <th>Date </th>
                            <th>Version </th>
                            <th>Description </th>
                        </tr>
                        <tr>
                            <td>19/12/2011 </td>
                            <td class="centered">1 </td>
                            <td>
                                <dl><dt>Assel</dt> <dd>Stakeholder concerns, key drivers, patterns</dd>
                                    <dt>Divya</dt> <dd>Introduction of the system and overview of contents</dd>
                                    <dt>Eamon</dt> <dd>System context text, SR diagram</dd>
                                    <dt>Edy</dt> <dd>System context diagram</dd>
                                    <dt>Sunna</dt> <dd>Document creation, stakeholders and concerns, patterns</dd>
                                </dl>
                            </td>
                        </tr>
                        <tr>
                            <td>9/1/2012 </td>
                            <td class="centered">2 </td>
                            <td>
                                <dl><dt>Sunna, Eamon</dt> <dd>Conversion from google docs into HTML on Mercurial; minor updates.</dd>
                                </dl>
                            </td>
                        </tr>
                        <tr>
                            <td>16/01/2012 </td>
                            <td class="centered">3 </td>
                            <td>
                                <dl><dt>Assel</dt> <dd>Pattern descriptions</dd>
                                    <dt>Divya</dt> <dd>Architectural View: logical, development </dd>
                                    <dt>Edy</dt> <dd>Architectural View: process, physical</dd>
                                    <dt>Sunna</dt> <dd>Chapter 3</dd>
                                    <dt>Eamon</dt> <dd>Pattern candidates, merge document + doc outline</dd>
                                </dl>
                            </td>
                        </tr>
                        <tr>
                            <td>23/01/2012 </td>
                            <td class="centered">4 </td>
                            <td>
                                <dl><dt>Assel</dt> <dd>Client-Server pattern</dd>
                                    <dt>Divya</dt> <dd>Interceptor Pattern</dd>
                                    <dt>Edy</dt> <dd>Add architectural diagram, refine views and reference</dd>
                                    <dt>Sunna</dt> <dd>Chapter 5, Proxy pattern</dd>
                                    <dt>Eamon</dt> <dd></dd>
                                </dl>
                            </td>
                        </tr>
                        <tr>
                            <td>12/02/2012 </td>
                            <td class="centered">5 </td>
                            <td>
                                <dl><dt>Assel</dt> <dd>Proxy pattern, evaluation and recomendation sections</dd>
                                    <dt>Divya</dt> <dd>Views, Interceptor pattern diagram, recommendations for Reverse Proxy pattern</dd>
                                    <dt>Edy</dt> <dd>Refine architectural diagram, sequence diagram, relaxed layer pattern</dd>
                                    <dt>Sunna</dt> <dd>Chapter 5, Client-Server & Peer-to-peer patterns, diagrams: CS, P2P and system overview, Glossary, final additions chapter 2,3,4,5</dd>
                                    <dt>Eamon</dt> <dd></dd>
                                </dl>
                            </td>
                        </tr>

                    </tbody>
                </table>
            </aside>
            <section id="section-introduction">
                <!-- Chapter 1 - Introduction -->
                <h1>Introduction </h1>
                <p>The document presents the pattern-based recovery and evaluation of the architecture of an open-source system,
                    Mercurial <a href="#bib-mercurial">[ref]</a>.
                    It is a distributed version control system. This document gives an overview of the patterns that represent
                    the core of the Mercurial system. We used the IDAPO <a href="#bib-idapo">[ref]</a> process for identifying the
                    architectural patterns in Mercurial. We
                    also discuss the specific variants of the patterns which we found, and evaluate the patterns
                    using Pattern-Based Architectural Review (PBAR) <a href="#bib-harrison2010pattern">[ref]</a> method.  The evaluation
                    of the patterns is based on the system's
                    quality attributes.</p>
                <p>The structure of the document is as follows: </p>
                <p><a href="#section-context">[ref]</a> describes the system context of the Mercurial version control system.
                    <a href="#section-stakeholders">[ref]</a> deals with identifying the stakeholders and their concerns as
                    well as the key drivers which should drive the development of the system. </p>
                <p><a href="#section-architecture">[ref]</a> describes several architectural views of the system and the architectural
                    patterns identified for the Mercurial system using IDAPO.
                    The specifics of each pattern's usage, the problem(s) it addresses, its consequences on the system, and other details
                    are also presented. Finally, we describe the architectural decomposition and the responsibilities of each component. </p>
                <p><a href="#section-evaluation">[ref]</a> is focused on the architectural evaluation of the Mercurial
                    system using the PBAR approach. It also shows how key drivers are addressed. </p>
            </section>
            <section id="section-context">
                <!-- Chapter 2 - System context -->
                <h1>System context <span class="rightbox"></span></h1>
                <p>Mercurial<sup> <a href="#merc_links" id="merc_links_ref">[ref]</a> </sup>is a distributed revision control system. It aims
                    to help developers manage changes (revisions) made to projects. Managing multiple versions of even a single document by
                    hand is an error-prone, time-consuming task. Mercurial allows a team of developers to manage large numbers of documents
                    with many versions. Although Mercurial can maintain a version history for arbitrary files and directories, it is designed
                    in particular to deal well with large numbers of complex text documents such as source code. There are several ways in which
                    Mercurial helps address the problems arising from collaborating on such code. </p>
                <section>
                    <h1>Mercurial’s functionality </h1>
                    <p>Firstly, Mercurial maintains a log: an annotated history of changes. In addition to keeping track of the documents themselves,
                        Mercurial allows developers to keep track of which lines were changed, the date the changes were made, the identity of the
                        author, and, importantly, the motivation for these changes. This is achieved by splitting changes into cohesive chunks called
                        changesets. When a developer commits a changeset, he adds it to Mercurial’s repository of changesets, and includes a commit
                        message describing what was changed and why. Changesets with commit messages are common in revision control systems; they
                        allow developers to maintain systems that are too large or too old by reducing the need to grasp the entirety of the system
                        at once. </p>
                    <p>Mercurial assists collaboration by allowing concurrent edits. When several people simultaneously change a set of files, their
                        changes need to be merged into a final version. Revision control systems such as Mercurial assist the user by largely automating
                        this process: if only one author changes a file, his version simply replaces the old one. When multiple authors change a
                        file in a format Mercurial understands (such as plain text), changes to non-overlapping regions are automatically merged.
                        Finally, where changes do conflict, they are reported, and the user can systematically compare the changes to resolve the
                        conflict. Automatic merging and conflict detection helps allow multiple developers work on the same project by avoiding
                        the friction of each developer keeping abreast of all changes. </p>
                <figure id="fig-common-hg-setup">
                    <img src="images/SystemOverview.png" alt="System overview diagram" />
                    <figcaption>From <a href="#system_overview_diagram_links" id="system_overview_diagram_links_ref">[ref]</a>. A common mercurial workflow;
                        Joe &amp; Dan interact with their own repository which contains the entire project history.  Changes are usually exchanged via a central repository.</figcaption></figure>
                    <p>Mercurial allows distributed development teams by allowing any developer to pull others’ changes or push his own to an external
                        repository (see <a href="#fig-common-hg-setup">[ref]</a>). Crucially, there is no technical need for a central repository nor for “one true” history, allowing for truly
                        distributed development. In particular, each committed changeset is uniquely identifiable, allowing Mercurial to avoid applying
                        changes it has already seen, even if those changes depend on each other in non-trivial ways. Mercurial’s logged history
                        is conceptually a directed acyclic graph. Thus when two versions are merged that (partially) share the same history, the
                        shared part of the history is not duplicated. </p>
                    <p>These three features enable many useful scenarios. For instance, in a large system, development mistakes are made. Since
                        it maintains a history of changes and the details of each changes, Mercurial can revert a particular change e.g. to correct
                        a mistake. Unlike a strictly linear process, such a reverted change does not require the user to redo all subsequent changes;
                        instead, the reverted change is itself a new changeset that can be merged anywhere into the version history. </p>
                </section>
                <section>
                    <h1>Project history and community</h1>
                    <p>Matt Mackall is the creator of Mercurial and has been working on the system as the main developer since 2005 <a href="#matt_mackall">[ref]</a>.  Mercurial's creation was a response to the Linux kernel's search for an alternative to BitKeeper <a href="#aosabook">[ref]</a>.  Although the kernel ended up using Git, a similarly new SCM by Linus Torvalds, Mercurial was subsequently adopted by several other OSS projects. The origins in the linux kernel development community motivated two of Mercurial's key requirements: the ability to scale up to a large repositories with many revisions, and the need to support a truly distributed development style.</p>
                    <p>Mercurial has an active community<a href="#community">[ref]</a>, that can be reached via various mailing lists, depending on your needs. <a href="#mailinglist">[ref]</a>
                        For a fast response to your questions you can reach Mercurial developers on IRC, where they even provide a
                        timetable when various developers are likely to be using the IRC. <a href="#irc">[ref]</a></p>
                </section>
            </section>
            <section id="section-stakeholders">
                <!-- Chapter 3 - Stakeholders and concerns -->
                <h1>Stakeholders and concerns <span class="rightbox"></span></h1>
                <section>
                    <h1>Stakeholders and concerns</h1>
                    <p>Stakeholders and their concerns have been identified by reading the documentation and analyzing the functionality of
                        the system. Stakeholders are not specifically defined in Mercurial documentation, but the benefits for end-users are listed
                            <a href="#about-mercurial">[ref]</a>. </p>
                    <dl><dt>End user</dt> <dd>The end user (software developer) can be a large team of people as well as one person. </dd>
                        <dt>Mercurial project leader</dt> <dd>Matt Mackall is the sole full-time developer working on Mercurial and is also the project
                            leader, serving as a gatekeeper, validating third-party contributions <a href="#mercurial-dev-process">[ref]</a>.  His stated aims in creating Mercurial were to create a simple, scalable, efficient, and distributed SCM <a href="#bib-hg-lkml-announcement">[ref]</a>.</dd>
                        <dt>Core Mercurial software developers</dt> <dd>Several other software developers regularly contribute to various Mercurial
                            components. </dd>
                        <dt>Patch/extension developer</dt> <dd>Mercurial welcomes patches and extensions from any software developer. </dd>
                    </dl>
                    <table class="bookstyleborders">
                        <tbody>
                            <tr>
                                <th>Stakeholder </th>
                                <th>Concerns </th>
                            </tr>
                            <tr>
                                <td>End user </td>
                                <td>
                                    <dl><dt>Reliability:</dt> <dd>The system should be stable and available even in the face of an unreliable network connection.
                                    </dd>
                                        <dt>Durability:</dt> <dd>The system should not lose data even in the face of a crash</dd>
                                        <dt>Extensibility:</dt> <dd>The system should be flexible and adaptable to users' needs and workflows </dd>
                                        <dt>Scalability:</dt> <dd>They system should be able to deal with large projects having many files and many changesets.
                                        </dd>
                                        <dt>Usability:</dt> <dd>The system should be easy to use and easy to learn </dd>
                                        <dt>Performance:</dt> <dd>The system should work quickly on projects of any size. </dd>
                                        <dt>Portability:</dt> <dd>The system should work interoperably on common platforms</dd>
                                    </dl>
                                </td>
                            </tr>
                            <tr>
                                <td>Mercurial project leader </td>
                                <td>
                                    <dl><dt>Modifiability: </dt><dd>The system should be simple enough to be easily changed or extended. </dd>
                                        <dt>Scalability:</dt><dd>The system should scale to large projects such as the Linux Kernel or Mozilla Firefox.</dd>
                                        <dt>Efficiency:</dt><dd >The system should use minimal memory, disk I/O and bandwidth</dd>
                                        <dt>Distributed:</dt><dd>The system should allow a distributed development style without requiring centralized control.</dd>
                                    </dl>
                                </td>
                            </tr>
                            <tr>
                                <td>Mercurial software developer </td>
                                <td>
                                    <dl><dt>Modifiability:</dt><dd>The code should be well documented and easy to change and extend.</dd>
                                        <dt>Efficiency:</dt> <dd>For effective work of the system WAN bandwidth and disk seek rate should be optimized for the system.
                                        </dd>
                                    </dl>
                                </td>
                            </tr>
                            <tr>
                                <td>Patch/ extension developers </td>
                                <td>
                                    <dl><dt>Extensibility:</dt> <dd>The system should be flexible enough to accommodate diverse needs as easily as possible.</dd>
                                    </dl>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </section>
                <section>
                    <h1>Key drivers</h1>
                    <p>The key drivers are identified in Mercurial's documentation <a href="#key_drivers">[ref]</a>. These key drivers
                        are talked about extensively in several Mercurial sources. They not prioritized in the documents and therefore
                        are listed in arbitrary order below.</p>
                    <dl>
                        <dt>Usability:</dt> <dd>The basic interface of Mercurial is easy to use, easy to learn and hard to break. Mercurial sports
                            a consistent command set and potentially dangerous actions are available via extensions which need to be enabled. </dd>
                        <dt>Extensibility:</dt> <dd>The functionality of Mercurial can be increased with extensions, either by activating bundled extensions, downloading third party extensions, or
                            by easily writing a new one.</dd>
                        <dt>Portability:</dt> <dd>Mercurial is written with platform independence in mind. Binary releases are available on all major
                            platforms. </dd>
                        <dt>Performance:</dt> <dd>Mercurial is designed to be fast. One can generate diffs between revisions, or jump back in time within
                            seconds. </dd>
                        <dt>Reliability:</dt> <dd>Mercurial is truly a distributed system, which gives each developer a local copy of the entire development
                            history. This way it works independent of network access or a central server. </dd>
                    </dl>
                </section>
            </section>
            <section id="section-architecture">
                <!-- Chapter 4 Architecture -->
                <h1>Architecture <span class="rightbox"></span></h1>
                <p>According to its available document on website <a href="#mercurial-arch">[ref]</a>, the general overview of Mercurial architecture can be depicted below. 		</p>
                <figure>
                    <img src="images/Mercurial-comp-diag.png" alt="Mecurial component diagram"/>
                    <figcaption >Mercurial Architectural Diagram based on <a href="#mercurial-arch">[ref]</a></figcaption>
                </figure>
                <p> Since Mercurial can be seen as peer-to-peer application, each peer has the same structure as the other. Each peer represents a node which contains five layers basically. Seen from bottom-up view, the layers for each peer are Utility, UI, Storage, Repository, and Interface. In general, no layer should know the details of any layer above it, and no layer should abuse the interface of layers below it <a href="#mercurial-arch">[ref]</a>. However, the layers are not truly strict since a certain layer can access the bottom layer directly.</p>
<!-- Interface
                            layer is the topmost layer and is the part most directly exposed to the user. It contains commands.py, an implementation
                            of the command line interface which contains most of the code that deals with converting commands into simple repository
                            operations as well as the stdio push/pull interface, and hgweb.py, an implementation of the web interface which contains
                            all the web and templating logic as well as the web based push/pull interface. The second one, Repository layer contains
                            all the objects that implement the core primitives of the SCM such as commit, checkout/update/merge, push/pull, add/remove/copy,
                            verify, and the proxy objects for remote repositories (remoterepository, sshrepository, httprepository, httpsrepository,
                            statichttprepository) and the objects from which the repository is constructed (filelog, manifest, changeset, dirstate).
                            The third one, Storage layer contains the basis for version storage, revlog. The fourth one, UI layer provides generic methods
                            for communicating with the user and managing configuration info. The fifth layer, Utility layer includes generic functionality
                            and platform abstraction <a href="#mercurial-arch">[ref]</a>. -->
                <p>One interesting point is there are two layers that seem similar, Interface layer and UI (User Interface) layer. Based on investigation in source
                    code, the interface layer deals with commands which the end-user could execute e.g. add, commit and update, while UI layer deals with the message
                    which is delivered to end-user regarding to the command execution.</p>
                <section>
                    <!--################################### From Views.html ###############-->
                    <h1>Architectural views </h1>
                    <section id="section-logical-view">
                        <h1>Logical view </h1>
                        <p>The logical view for the Mercurial describes the functionality of the Mercurial
                            system to the end-users. Mercurial is a modern distributed version control system (DVCS)
                            which is written in Python. The architecture of Mercurial is decomposed logically into five layers. It is basically follows a Relaxed Layer pattern.
                            The bottommost layer is the utility layer which implements handler. It includes generic functionality
                            and platform abstraction. The next layer is the User Interface Layer. It implements a
                            TextBasedMethod and provides generic methods for communicating with the user and managing configuration info. The storage layer consists of a storage component which is used to implement versioning of the system. It contains the basis for version storage, revlog.
                            The repository layer consists of two components SCMcore and Repository Proxy. The SCMCore implements core primitives such as commands like pull,
                            update, add, commit and push. The Hg update is used to update the file in the given repository. The Hg add is used to add
                            any file. The Hg commit is used to commit any changes in the file. The Hg push is used to push the file into the repository.
                            The remoting interface (push or pull) is used between SCMcore and RepositoryProxy. There are proxy objects for remote repositories (remoterepository, sshrepository, httprepository, httpsrepository,
                            statichttprepository) inside RepositoryProxy. The interface layer consists of
                            two components, Hgweb and Command. This layer is basically the layer in which users interact with the system.
                            Hgweb has web interface and Command component has command-line interface <a href="#mercurial-arch">[ref]</a>.
                            <!-- The sequence diagram for the Logical view is depicted as follows: -->

            </p>
            <p>Regarding data model, Mercurial uses a generic structure of historic data, called revlog. There are three types of revlogs: the changelog, manifests,
                and filelogs. The changelog contains metadata for each revision, with a pointer into the manifest revlog (that is, a node id for one revision in the
                manifest revlog). In turn, the manifest is a file that has a list of filenames plus the node id for each file, pointing to a revision in that file's filelog.
                In the code, there are classes for changelog, manifest, and filelog that are subclasses of the generic revlog class, providing a clean layering of both
                concepts <a href="#aosabook">[ref]</a>.	</p>
            <figure id="fig-hg-revlog-model">
                <img src="images/revlogs.png" alt="Mercurial generic data model, revlog"/>
                <figcaption >Mercurial Generic Data Model, Revlog <a href="#aosabook">[ref]</a></figcaption>
            </figure>
            <p>Mercurial is a command-line application. This means a simple interface, the user calls the hg script with a command. This command (like log, diff or commit)
                may take a number of options and arguments. There are also some options that are valid for all commands. Next, there are three different things that can
                happen to the interface: hg will often output something the user asked for or show status messages, hg can ask for further input through command-line
                prompts, hg may launch an external program (such as an editor for the commit message or a program to help merging code conflicts). The correlations
                between modules is depicted below.</p>
            <figure>
                <img src="images/modules.png" alt="Mercurial module dependancies"/>
                <figcaption >Mercurial Modules Correlation <a href="#aosabook">[ref]</a></figcaption>
            </figure>
                    </section>

                    <section>
                        <h1>
                            <!--Edy-->
                            Process view </h1>
                        <p>The process view of Mercurial depicts the interaction of processes or objects during
                            runtime. When Mercurial tracks modifications to a file, it stores the history of
                            that file in a metadata object called a 'filelog'. Mercurial uses a structure called
                            a 'manifest' to collect together information about the files that it tracks. Each
                            entry in the manifest contains information about the files present in a single changeset.
                            The 'changelog' contains information about each changeset. Within a changelog, a manifest,
                            or a filelog, each revision stores a pointer to its immediate parent (or to its
                            two parents, if it's a merge revision). For every changeset in a repository, there
                            is exactly one revision stored in the changelog. Each revision of the changelog
                            contains a pointer to a single revision of the manifest. A revision of the manifest
                            stores a pointer to a single revision of each filelog tracked when that changeset
                            was created. The underpinnings of changelogs, manifests, and filelogs are provided
                            by a single structure called the revlog. Mercurial only ever appends data to the
                            end of a revlog file. Mercurial treats every write as part of a transaction that
                            can span a number of files. A transaction is atomic: either the entire transaction
                            succeeds and its effects are all visible to readers in one go, or the whole thing
                            is undone. This guarantee of atomicity means that if user is running two copies
                            of Mercurial, where one is reading data and one is writing it, the reader will never
                            see a partially written result that might confuse it. In the working directory,
                            Mercurial stores a snapshot of the files from the repository as of a particular
                            changeset. When user updates the working directory to contain a particular changeset,
                            Mercurial looks up the appropriate revision of the manifest to find out which files
                            it was tracking at the time that changeset was committed, and which revision of
                            each file was then current. It then recreates a copy of each of those files, with
                            the same contents it had when the changeset was committed <a href="#mercurial-book-4">[ref]</a>.
                        </p>
            <p> According to the process view explained above, Mercurial process view is depicted in sequence diagram below.</p>
            <figure>
                        <img src="images/Mercurial-seq-diag.png" alt="Mercurial sequence diagram" />
                        <figcaption>Mercurial Sequence Diagram for Modify and Commit</figcaption>
                    </figure>

                    </section>
                    <!--section>
                        <h1>
                            Physical view </h1>
                        <p>The physical view depicts the system concerned with the topology of software components.  </p>
                    </section-->
                    <!-- ############################ END From Views.html ########### -->
                </section>
                <section>
                    <h1>Candidate Architectural Patterns </h1>
                    <p>The IDAPO process <a href="#bib-idapo">[ref]</a> was followed in the making of this report. In step 4 candidate patterns are
                        identified and listed. In steps 5-7 the documentation and source code is studied in detail
                        to assert that the candidate patterns are actually present. Below is the list of candidate
                        patterns and our conclusions on their presence in Mercurial.</p>
                    <dl><dt>Remote Proxy</dt> <dd>For accessing remote repositories from a local client. <i>Accepted</i> </dd>
                        <dt>Layers</dt> <dd>The levels of abstraction. <i>Rejected, as some layers are bypassed</i> </dd>
                        <dt>Relaxed Layers</dt> <dd>The levels of abstraction are more suitable as relaxed layers. <i>Accepted</i> </dd>
                        <dt>Peer-to-peer</dt> <dd>Mercurial itself implements such a system between repositories - it&#39;s arguable that it&#39;s a 
                        property of the system not within the system; but it&#39;s important to the architecture regardless. <i>Accepted</i> </dd>
                        <dt>Shared Datastore</dt> <dd>aka Shared Repository; renamed to avoid confusion with the term repository to meaning a Mercurial
                            SCM repository. The disk revlogs are shared between various other components and could be seen as a shared repository. <i>Accepted</i> </dd>
                        <dt>Indirection layer</dt> <dd>The revlog storage can be seen as an indirection layer over the filesystem: direct access is
                            problematic due to performance, corruption and locking. <i>Rejected; shared repository is a better match</i> </dd>
                        <dt>Active repository</dt> <dd>Active repository: the Mercurial VCS itself can be seen as an active repository in that it provides
                            hooks that can actively notify others of changes. Is this more like a feature than a pattern? <i>Rejected; 
                        implementation looks more like the Interceptor pattern.</i> </dd>
                        <dt>Interceptor</dt><dd>Mercurial allows for configurable external code to be executed at predefined points to allow for 
                        repository hooks and extension functionality. <i>Accepted</i> </dd>
                        <dt>Client-Server</dt> <dd>A Mercurial repository communicates via a client-server protocol when over the network e.g. when
                            pushing or pulling. <i>Accepted</i> </dd>
                    </dl>
                </section>
                <section>
                    <h1>Architectural patterns </h1>
                    <section>
                        <h1>Peer-to-peer </h1>
                        <figure>
                            <img src="images/Peer-to-peer.jpg" alt="Mecurial Peer-to-peer diagram"/>
                            <figcaption>Mercurials Peer-to-peer diagram</figcaption>
                        </figure>
                        <table class="bookstyleborders">
                            <tbody>
                                <tr>
                                    <th>Pattern Section </th>
                                    <th>Comments </th>
                                </tr>
                                <tr>
                                    <td>Name </td>
                                    <td>Peer-to-peer </td>
                                </tr>
                                <tr>
                                    <td>Problem Context </td>
                                    <td>
                                        <p>Mercurial is designed to allow for a truly distributed workflow, hence it is truly distributed. </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Solution Variant </td>
                                    <td>
                                        <p>In Mercurial each peer can act as both client and server, depending on the setup chosen. In Mercurial there is no need for
                                            a central repository. Each client clones (makes a full copy) the whole repository he is working on from another client,
                                            and is able to pull from that client and push to other clients at any time. While working, you only make changes to your
                                            local repository until you push the changes out.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Rationale </td>
                                    <td>
                                        <p>The peer-to-peer pattern allows for excellent reliability, since Mercurial is truly distributive and each user stores the
                                            whole repository on their local machine and users are not limited by network problems. Performance and usability is improved
                                            since local commits can be done without pushing remotely to a server (<a href="#bite_sized_mercurial">[ref]</a>,
                                            <a href="#intro_to_DVCS">[ref]</a>, <a href="#merc_links">[ref]</a>). </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Consequences </td>
                                    <td>
                                        <p>This pattern eliminates the problem of SOP (Single Point of Failure). As each componenent acts as a peer, time of request
                                            and time of response is reduced. This inturn will increase the communication speed and also increases work productivity.
                                            Peer-to-peer also increases scalability, since it does not limit the amount of users sharing one project. </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Related patterns </td>
                                    <td>
                                        <p>Client-Server</p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section>
                        <h1>Shared Datastore </h1>
                        <p>The Shared Datastore pattern is usually called <i>Shared Repository</i>: to avoid confusion with the term &ldquo;repository&rdquo;
                            which is used differently in the context of Mercurial the pattern is renamed here. <a href="#fig-hg-revlog-model">[ref]</a> (section <a href="#section-logical-view">[ref]</a>) shows the setup of the backend mercurial datastore.</p>
                        <table class="bookstyleborders">
                            <thead>
                                <tr>
                                    <th>Pattern Section </th>
                                    <th>Comments </th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Name </td>
                                    <td>Shared datastore </td>
                                </tr>
                                <tr>
                                    <td>Problem Context </td>
                                    <td>
                                        <p>Mercurial needs to store versioned data efficiently and robustly. Versioned data includes not just user-data (e.g. source
                                            code), but also metadata (e.g. commit messages), and the repository tree structure. </p>
                                        <p>All data stored in Mercurial must be stored efficiently, i.e. with low space and time overhead. Taking into account the performance
                                            characteristics of hard drives and the typical data storage patterns to optimize access while avoiding data corruption in
                                            the event of a crash or software bug is complex. In particular, SCM systems generally add new data but rarely (if ever)
                                            change existing data; stale data is read less frequently than the newest version; disk seeks are slow yet repositories may
                                            contain very many revisions with very many files so that the complexity of retrieving historical data should not depend
                                            on the size of the repository. </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Solution Variant </td>
                                    <td><p>Mercurial stores most of its data in <i>revlogs</i> <a href="#bib-hg-wiki-revlog">[ref]</a>. Each Mercurial repository has many such revlogs; most persistant data
                                        (whether Mercurial-internal or user data) is stored and managed centrally in these datastructures. Each revlog consists
                                        of an append-only data file and an index file with fixed-size entries (to enable O(1) seeking <a href="#bib-mackall2006betterscm">[ref]</a>) storing where a particular
                                        version is to be found in the data file. There are three classes of revlogs. Firstly, user data is stored in a per-file revlog.
                                        Secondly, a directory listing with revision numbers of each file forming a particular version of the directory tree is stored
                                        in a manifest revlog. Finally, changeset metadata such as commit messages and the corresponding manifest revision number
                                        is stored in a changeset revlog. </p></td>
                                </tr>
                                <tr>
                                    <td>Rationale </td>
                                    <td><p>Standardizing the data storage method using revlogs primarily supports the system's performance by ensuring versioned information can be accessed quickly regardless of the amount of revisions stored.  Additionally, the shared datastore simplifies extensibility partially by providing a uniform abstraction for many different types of data stored by mercurial.  Also, the shared datastore accounts for platform differences such as file system case-sensitivity and illegal characters, so that a repository can be copied between platforms without corruption simply by copying the repository's directory, which improves portability.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Consequences </td>
                                    <td><p>The revlog's simplicity improves durability:  Adding data to a shared datastore can be performed simply by appending data to the revlog and its index.  In addition to using OS locking to ensure atomic write access, the new revlog contents are appended before the new revlog index contents are so that if a write fails, it does not corrupt the repository <a href="#aosabook">[ref]</a>: failure during the content append never touches previous revisions and the corrupted data can simply be ignored.  Failure during the index append can either be recovered by a truncation (thus atomically failing the write without corruption), or by recomputation since the contents are already completely written.  In a similar fashion, dependencies between different revlogs are ordered so that any failure is can be rolled back and never affects previously stored revisions.</p><p>
                                    Furthermore, the typically append-only access pattern somewhat improves the usability goal of making it hard to make mistakes that result in data loss: access through Mercurial's API or user interface is almost always safe by virtue of the philosophy of never altering previously committed data.
                                    </p><p>Finally, the simplicity of the revlog format clearly improves modifiability of mercurial itself (a stated goal of mercurial's maintainer).</p></td>
                                </tr>
                                <tr>
                                    <td>Related patterns </td>
                                    <td>None of the identified patterns </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section>
                        <h1>Client server </h1>
                        <figure>
                            <img src="images/ClientServer.jpg" alt="Mecurial Client Server diagram" />
                            <figcaption>Mercurials Client server diagram</figcaption>
                        </figure>
                        <table class="bookstyleborders">
                            <tbody>
                                <tr>
                                    <th>Pattern Section </th>
                                    <th>Comments </th>
                                </tr>
                                <tr>
                                    <td>Name </td>
                                    <td>Client-Server </td>
                                </tr>
                                <tr>
                                    <td>Problem Context </td>
                                    <td><p>Two components who are independent from each other need to communicate with each other and even run on different computers
                                        (Mercurial is a distributed system). One of the peers initiates communication by sending a request to other peers.
                                        The server must cope with multiple requests at the same time from several peers.  Clients wich are
                                        using the same server may have different local versions.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Solution Variant </td>
                                    <td><p>The Client-Server pattern consists of two kinds of components: clients and servers. In Mercurial the server consists of
                                        http component, ssh component or local disk component, depending on how the user decides to set up the repository. The client
                                        communicates to the server components depending on the users choise. </p></td>
                                </tr>
                                <tr>
                                    <td>Rationale </td>
                                    <td><p>Due to the fact the Mercurial is truly distributed and uses Peer-to-peer pattern (see above), it is necessary to have a
                                        Client Server pattern. Portability is the key driver supported by this pattern since the pattern allows for high level
                                        communication protocols which can be implemented on most major plattforms. </p></td>
                                </tr>
                                <tr>
                                    <td>Consequences </td>
                                    <td><p>Usability is affected in a negative way since setting up repositories can be difficult, depending on the approach chosen
                                        <a href="#merc_repositories">[ref]</a>.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Related patterns </td>
                                    <td>Peer-to-peer, Remote Proxy </td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section>
                        <h1>Remote Proxy</h1>
                        <figure id="fig-remote-proxy">
                            <img src="images/Proxy.jpg" alt="Mecurial Proxy diagram"  />
                            <figcaption>Mercurials Proxy diagram</figcaption>
                        </figure>
                        <table class="bookstyleborders">
                            <tbody>
                                <tr>
                                    <th>Pattern Section </th>
                                    <th>Comments </th>
                                </tr>
                                <tr>
                                    <td>Name </td>
                                    <td>Remote Proxy <a href="#mercurial-arch">[ref]</a></td>
                                </tr>
                                <tr>
                                    <td>Problem Context</td>
                                    <td>
                                        <p>Client applications should be able to access remote and local repositories in a transparent manner. In a Mercurial users start by cloning a copy of 
                                            a repository. They can synchronize changesets with it (or another repository) whenever they need to, and
                                             other developers can do so concurrently. However, there are many different ways of communicating with a remote 
                                            repository depending on its type.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Solution Variant</td>
                                    <td>
                                        <p>To avoid the complexity, a Mercurial repository communicates via an internal representation called a proxy, which 
                                            presents an abstract API covering the details of access to the remote repository.
                                        It is implemented in the client and contacts any server type such as http, https, ssh, a different directory on the local disk, 
                                            or even an extension-provided implentation such as for Git or Subversion interoperability (see <a href="#fig-remote-proxy">[ref]</a>).  The proxy object is a surrogate or placeholder for the other repository and controls access to it <a href="#remote_proxy">[ref]</a>.  The client mercurial module makes a request to the proxy.                                      The Proxy forwards the request using the proper communication protocols (pipelined request/response protocol) and security measures.
                                        The remote repository accepts the request and attempts to fulfill it. It sends the response back to the proxy.  The proxy interprets the response, and translates it into a canonical representation which is returned to the client.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Rationale </td>
                                    <td><p>
                                        Encapsulating complexity within a proxy object simplifies the internal API, improving extensibility by simplifying 
                                        development and/or configuration of extensions.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Consequences </td>
                                    <td>
                                        <p>&nbsp;One of the benefits of using a proxy object is that it hides the fact that an object resides elsewhere.
                                        The proxy object is responsible for all the networking complications, which could improve usability (by simplifying 
                                            configuration), maintainability, and modifiability.
                                        The proxy hides the fact that a service is provided remotely, and makes the remote service as easy to use as a local service.
                                        By putting all location information and addressing functionality into a Remote Proxy variant, clients are less affected by migration of servers or
                                        changes in the networking infrastructure. This allows client code to become more stable and reusable.</p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Related patterns </td>
                                    <td>Client-server, peer-to-peer</td>
                                </tr>
                            </tbody>
                        </table>
                    </section>
                    <section id="interceptor">
                      <h1>Interceptor</h1>
                      <figure id="fig-mercurial-interceptor">
					         <img src="images/Interceptor.png" alt="Mecurial Interceptor diagram"  />
					         <figcaption>Mercurial Interceptor diagram</figcaption>
					  </figure>

                      <table class="bookstyleborders">
                          <tr>
                             <th>Pattern Section</th>
                             <th>Comments</th>
                          </tr>
                          <tr>
                             <td>Name</td>
                             <td>Interceptor</td>
                          </tr>
                          <tr>
                             <td>Problem Context</td>
                             <td>
                                 <p>Mercurial has been designed to be part of a continuous integration system that builds and tests software automatically
                                    and regularly</p>
                             </td>
                          </tr>
                          <tr>
                             <td>Solution Variant</td>
                             <td>
                                 <p>The pattern detected is Interceptor for Mercurial. Interceptor defines the signatures of the hook methods.
                                    Hook is a code which handles intercepted function calls,messages and events. They provide a way for version control systems like
                                    Mercurial to interact with the outside world.For example if we want to send an email automatically after commit occurs we have Commit hook.
                                    We can also invoke a hook if we want to send a mail containing all changesets of a push/pull/unbundle.In Mercurial,
                                    users/developers can invoke Python hooks by specifying a Python module and a function name to call from that module.
                                    The Mercurial framework facilitates the registration of interceptors through dispatchers.</p>
                             </td>
                          </tr>
                          <tr>
                             <td>Rationale</td>
                          <td>
                                 <p>The advantages of detecting interceptor pattern is they are associated with a particular set of events. This mainly improves flexibility.
                                    Concrete interceptors specialize interceptor interfaces and implement the hook methods of Mercurial to handle events in an application-specific manner.
                                    The interceptor pattern helps to achieve usability and extensibility.</p>
                          </td>
                         </tr>
                         <tr>
                             <td>Consequences</td>
                          <td>
                                 <p>This pattern includes strict seperation of framework and interceptors allows independent
                                    variation and evolution of service extensions in Mercurial.
                                    The complexity of the code increases thereby decreasing maintainability.</p>
                          </td>
                        </tr>
                        <tr>
                            <td>Related patterns</td>
                            <td>
                                 <p>No patterns identified</p>
                            </td>
                           </tr>
                      </table>
                    </section>
                    <section>
                        <h1>Relaxed Layers</h1>
                 	<figure>
		         <img src="images/Mercurial-relaxedlayer.png" alt="Mecurial Relaxed Layers  diagram" />
		         <figcaption>Mercurial Relaxed Layers diagram</figcaption>
			</figure>

                        <table class="bookstyleborders">
                            <tr>
                                <th>Pattern Section </th>
                                <th>Comments </th>
                            </tr>
                            <tr>
                                <td>Name </td>
                                <td>Relaxed Layers <a href="#posabook">[ref]</a></td>
                            </tr>
                            <tr>
                                <td>Problem Context</td>
                                <td>
                                    <p>Mercurial has to be designed with separation of concern, capability to extend, and platform independence
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>Solution Variant</td>
                                <td>
                                    <p>The separation of concern and extensibility are resolved by dividing Mercurial
                                        system into several modules and grouping them into some layers based on their level of abstraction.  Platform dependency can also be avoided by providing particular module. </p>
                                </td>
                            </tr>
                            <tr>
                                <td>Rationale </td>
                                <td>
                                    <p>The advantage of choosing relaxed layer pattern is the separation of modules into layers but still maintaining the flexibility
                                        among modules of different layers, e.g. between top layer with bottom layer, to interact directly. The layers also enables
                                        developer or patch/extent developer to extend Mercurial features separately without interfering with other modules or layers.
                                        The separation of modules allows the system to be developed in different platforms. </p>
                                </td>
                            </tr>
                            <tr>
                                <td>Consequences </td>
                                <td>
                                    <p>This pattern allows layers to interact without passing through any intermediate layer. This could be a problem when a
                                        component in a lower layer changes, the developer must examine not only its upper layer but also any layers above which interact
                                        directly to it. This could reduce maintainability.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Related patterns </td>
                                <td>
                                    <p>None of the identified patterns</p>
                                </td>
                            </tr>
                        </table>
                    </section>
                    <!--<section>
                    <h1>
                        Decomposition, component responsibilities &amp; interfaces</h1>
                </section>-->
                </section>
            </section>
            <!--####################### Evaluation and recommendations chapter ###################-->
            <section id="section-evaluation">
                <h1>Evaluation &amp; recommendations <span class="rightbox"></span></h1>
                <p>PBAR <a href="#bib-harrison2010pattern">[ref]</a> has been followed and in this section we evaluate the identified patterns based on the key-drivers.
                    In recommendations issues are identified and given suggestions to solutions, as well as future recommendations. </p>
                <section>
                    <h1>Evaluation</h1>
                    <p>We followed PBAR to evaluate the key drivers based on the patterns detected. If a key driver has
                        a positive impact on the pattern, it gets a plus with green background, if a key driver has a
                        negative impact on the pattern, it gets a minus with a red background, if a key driver has both a
                        positive and a negative impact (two different situations) on the pattern, it gets a plus slash minus
                        with a yellow background and finally if the impact
                        is neutral (no impact) then it is left blank with a white background.The rationale for the
                        evaluation is depicted below.</p>
                    <table class="simpleborders">
                        <tbody>
                            <tr>
                                <th></th>
                                <th>Usability </th>
                                <th>Extensibility </th>
                                <th>Portability </th>
                                <th>Performance </th>
                                <th>Reliability </th>
                            </tr>
                            <tr>
                                <th>Peer-to-peer </th>
                                <td class="posneg-impact-cell">+/-</td>
                                <td></td>
                                <td></td>
                                <td class="positive-impact-cell">+ </td>
                                <td class="positive-impact-cell">+ </td>
                            </tr>
                            <tr>
                                <th>Shared Datastore </th>
                                <td></td>
                                <td class="positive-impact-cell">+ </td>
                                <td class="positive-impact-cell">+ </td>
                                <td class="posneg-impact-cell">+/- </td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Client server </th>
                                <td class="negative-impact-cell">- </td>
                                <td></td>
                                <td class="positive-impact-cell">+ </td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Proxy </th>
                                <td class="positive-impact-cell">+ </td>
                                <td class="positive-impact-cell">+ </td>
                                <td></td>
                                <td > </td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Interceptor </th>
                                <td class="positive-impact-cell">+</td>
                                <td class="positive-impact-cell">+</td>
                                <td></td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <th>Relaxed Layers </th>
                                <td></td>
                                <td class="positive-impact-cell">+ </td>
                                <td class="positive-impact-cell">+ </td>
                                <td></td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                    <dl>
                        <dt>Peer-to-peer</dt> <dd>
                            <p>Usability and performance are improved since local changes do not have to be pushed onto a central server and therefore network
                                problems do not affect your work. Usability also gets a minus because when users are not actively pushing and pulling
                                changes it can cause a difficult merge wich can take some time to work out.</p>
                            <p>Reliablity is improved because every user has a local copy of the whole repository on his local machine. </p>
                        </dd>
                        <dt>Shared Datastore</dt> <dd>
                            <p>The revlog-based shared datastore patterns improves performance by allowing O(1) seek access regardless of the number of
                                revisions stored. Furthermore, the name-mangling approach to revlog storage improves performance in the face of file system
                                defragmentation. Also, the mangling ensures revlog names do not depend on platform-sensitive characters, enhancing portability.
                                Finally, by hiding complex changeset storage implementation details behind a simple, clean API, extensibility is improved
                                by allowing extension developers to modify the system behavior without being confronted with the complex internals.
                            </p>
                        </dd>
                        <dt>Client-Server</dt> <dd>
                            <p>Portability is the key driver which is addressed by this pattern. Allowing for several different communication protocols
                                to repositories and between computers, as well as supporting those for all major OS's. </p>
                            <p>Usability gets a minus due to the fact that it can be difficult to set up and configure you own repository <a href="#merc_repositories">[ref]</a> if you choose to do so. </p>
                        </dd>
                        <dt>Proxy</dt> <dd>
                            <p>The main reason to pick remote proxy is it increases extensibility, it creates for each client local representative of a central repository and increases the number of classes and objects
                                         that resides in a different address space.</p>
                            <p>The remote proxy is responsible for all the network hassle, so it could influence in usability in a good way.
                                        The proxy hides the fact that a service is provided remotely, and makes the remote service as easy to use as a local service. </p>
                        </dd>
                        <dt>Interceptor</dt>
<dd><p>Usability is the key-driver addressed in this pattern.Concrete interceptors help to handle events in an application
                        specific manner therby satisfying usability. Hence usability gets a plus. Extensibility is also a key-driver which
                        allows independent variation an evolution of service extensions in Mercurial. Hence extensibility is given a plus.</p></dd>
                        <dt>Relaxed Layers</dt>
			<dd>
			<p>Since Mercurial was developed in layers and modules, its functionality can be extended by module-based development inside certain layer. It is flexible to add new modules as new requirement might appear. Developing new module can be done without interfering other modules. Thus, extensibility increases. </p>
			<p>Mercurial has repository layer which contains proxy object. This layer enables developer to implement specific platform-based module especially in term of remote repository. This mechanism allows Mercurial to be more platform independent, so it increases portability.</p>
			</dd>
                    </dl>
                </section>
                <section>
                    <h1>Recommendations</h1>
                    <p>Emphasize on recommendations on how to improve the system. </p>
                    <section>
                        <h1>New features: recommended patterns</h1>
                        <p>Add languages to the UI ... what pattern to use (MVC?) ...how would that affect the existing architecture</p>
                    </section>
                    <section>
                        <h1>Improve existing patterns</h1>
                        <p>Are there any patterns that could be implemented better ...how would that affect the existing architecture</p>
                        <p>One problem of the Mercurial system is in concurrent clients/users access. More precisely, when multiple clients are trying push their changes at the same time,
                        they will often encounter multiple heads (multiple new versions) whose changes need to be resolved. To solve the issue we recommend to use mixed proxy pattern, i.e. group together Remote and Synchronization
                         variants of proxy pattern. One part is the Remote, it gets the same duties as held, provides a local representative for an object that resides in a different address space.
                         The other part of the combined proxy ia a Synchronization proxy will control multiple simultaneous client accesses, i.e. only one client can access the original files at a time,
                          the proxy can implement mutual exclusion via semaphores. Semaphore mechanism will be implemented in such way that could hold clients to access the original documents while other
                           user is using it. Remote proxy increases extensibility, but with Synchronization proxy it will improve reliability as well. <a href="#POSA2">[ref]</a></p>
			<p>The employment of relaxed layers pattern by Mercurial is proper enough. However, the naming of interface layer and UI layer seems ambiguous. It would more make sense if UI layer is renamed as User Message Manager, for instance, since it deals with messaging. Otherwise, the layers should be reorganized to meet common relaxed layers, from interface layer go deeper into core layer. Although relaxed layers pattern could decrease maintainability<a href="#posabook">[ref]</a>, this is acceptable since maintainability is not key-driver: also, as the interaction between the lower layers is minimal, the maintainability is unlikely to decrease in practice.
			</p>
                    </section>
                    <section>
                        <h1>Important key drivers (QA's) not addressed by existing patterns or many + and - in one pattern</h1>
                        <p>In the document, we mentioned usability as a key-driver, but it has not been addressed by most of the detected patterns.
                        We recommend Integration Reverse Proxy which provides a homogenous view of collection of servers, without
                        leaking the physical distribution of individual machines to end users. This will also provide security to the data
                        from the end users. This patterns will improve usability as per the user/developer perspective. We can implement this in our system
                        by configuring a back-end for Hgweb server.[<a href="#security">Security patterns Book</a>] </p>
                        <p></p>
                    </section>
                </section>
            </section>
            <aside class="glossary">
            <h1>Glossary</h1>
                <table class="simpleborders">
                    <tbody>
                        <tr>
                            <th>changelog</th>
                            <td>The changelog is part of a Mercurial repository. It contains all changesets of a repository and
                                is stored in revlog format. For each changeset of the repository, there is exactly one file
                                revision in the revlog file. <a href="#changelog">[ref]</a></td>
                        </tr><tr>
                            <th>changeset</th>
                            <td>An atomic collection of changes to files in a repository. I contains all recorde local
                                modification that lead to a new revision of the repository. <a href="#changeset">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>cloning</th>
                            <td>To clone a repository is to make a copy of it at a point in time. The new repository is self-contained. <a href="#cloning">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>commit</th>
                            <td>The creation of a new changeset in a repository, based on the state of the working directory. <a href="#commit">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>conflict</th>
                            <td>A conflict occurs when two independent changesets modify overlapping sections of a file in
                                different ways. During a merge, Mercurial may require the assistance of the user through a
                                merge program which can be used to resolve those conflicts. <a href="#conflict">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>diff</th>
                            <td>The term diff can mean one of two things:
                            <ul><li>The term originally referred to the diff program, which generates a text file that describes
                                the differences between two files or source trees.</li>
                                <li>These days, the term is typically used to describe one of its output files, as a synonym for
                                patch file. <a href="#diff">[ref]</a></li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <th>dirstate</th>
                            <td>Mercurial tracks various information about the working directory (the dirstate):
                            <ul><li>
                                what revision(s) are currently checked out</li>
                                <li>what files have been copied or renamed</li>
                                <li>what files are controlled by Mercurial <a href="#dirstate">[ref]</a></li>
                                </ul>
                            </td>
                        </tr>
                        <tr>
                            <th>DVCS</th>
                            <td>Distributed Version Control System</td>
                        </tr>
                        <tr>
                            <th>filelog</th>
                            <td>When Mercurial tracks modifications to a file, it stores the history of that file in a metadata
                                object called a filelog. Each entry in the filelog contains enough information to reconstruct one
                                revision of the file that is being tracked. A filelog contains two kinds of information: revision
                                data, and an index to help Mercurial to find a revision efficiently. <a href="#filelog">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>head</th>
                            <td>A head is a changeset with no child changesets. The tip is the most recently changed head.
                                Other heads are recent pulls into a repository that have not yet been merged. <a href="#head">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>hg</th>
                            <td>The hg command (hg and then e.g. help, pull, push) provides a command line interface to
                                the Mercurial system.</td>
                        </tr>
                        <tr>
                            <th>hook</th>
                            <td>A code which handles intercepted function calls, messages and events which are
                                implemented as either external programs or internal python calls. <a href="#interceptor">[ref]</a><a href="#hook">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>IDAPO</th>
                            <td>A Process for Identifying Architecture Patterns in OSS <a href="#bib-idapo">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>log</th>
                            <td>An annotated history of changes</td>
                        </tr>
                        <tr>
                            <th>manifest</th>
                            <td>The manifest is the file that describes the contents of the repository at a particular
                                changeset ID. It primarily contains a list of file names and revisions of those files
                                that are present. The manifest ID identifies the version of the manifest that goes with
                                a particular changeset. The manifest ID is a nodeid. Multiple changesets may refer to
                                the same manifest revision. <a href="#manifest">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>merge</th>
                            <td>A merge combines two separate changesets in a repository into a merge changeset that
                                describes how they combine. Merging is the process of joining points on two branches
                                into one, usually at their current heads. <a href="#merge">[ref]</a> </td>
                        </tr>
                        <tr>
                            <th>O(1)</th>
                            <td>A kernel scheduling design that can schedule processes within a constant amount of time,
                                regardless of how many processes are running on the operating system.</td>
                        </tr>
                        <tr>
                            <th>OS</th>
                            <td>Operating System</td>
                        </tr>
                        <tr>
                            <th>parent</th>
                            <td>A parent revision serves as a baseline for defining a set of changes.
                                Such a set of changes can either be a changeset in the repository or the local modifications
                                in the working directory. The parent revision(s) of the working directory will naturally be
                                used as the parent revision(s) of the changeset created by committing the local modifications. <a href="#parent">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>PBAR</th>
                            <td>Pattern-Based Architectural Review <a href="#bib-harrison2010pattern">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>pull</th>
                            <td>A pull propagates changesets from a "remote" repository (the source) into a local repository
                                (the destination). The source (or "remote") repository may be located on the same or on a different
                                computer. In the latter case, the changes are pulled over the network using the protocol specified
                                by the provided URL of the remote repository. Pull transfers only changesets which are missing in
                                the destination repository. <a href="#pull">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>push</th>
                            <td>A push propagates changes from a local repository to a remote one. <a href="#push">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>repository</th>
                            <td>In Mercurial the repository contains the history of your project. Strictly speaking, the term repository
                                in Mercurial refers to the directory named .hg (dot hg) in the repository root directory. The repository
                                root directory is the parent directory of the .hg directory. Mercurial stores its internal data structures
                                – the metadata – inside that .hg directory. <a href="#repository">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>revision</th>
                            <td><p>In Mercurial, the term revision can have two different meanings, depending on context.
                                Most often, "revision" refers to a distinct changeset in a repository, for example by specifying a
                                repository-localrevision number for the --rev option of the hg update or the hg merge command
                                (conceptually referring to "a revision of the repository"). The term "revision" is also used as the
                                short form for the longer term "file revision", which refers to a certain version of a file stored in
                                the repository (conceptually referring to "a revision of a file").</p><p>
                                This dual-use of the term "revision" naturally follows from the fact that Mercurial uses the same
                                technical method for storing changeset information and for storing file versions in the repository,
                                namely the revlog format. <a href="#revision">[ref]</a></p></td>
                        </tr>
                        <tr>
                            <th>revlog</th>
                            <td>A revlog, for example .hg/data/somefile.d, is the most important data structure and represents all versions
                                of a file in a repository. Each version is stored compressed in its entirety or stored as a compressed binary
                                delta (difference) relative to the preceeding version in the revlog. Whether to store a full version is decided
                                by how much data would beneeded to reconstruct the file. This system ensures that Mercurial does not need huge
                                amounts of data to reconstruct any version of a file, no matter how many versions are stored. <a href="#bib-hg-wiki-revlog">[ref]</a> </td>
                        </tr>
                        <tr>
                            <th>SCM</th>
                            <td>Abbreviations: "software configuration management" or "software configuration manager".
                                The automated management of the components of a software project as it evolves. There are two kinds of SCM:
                                CentralisedSCM and DistributedSCM. Mercurial is a distributed SCM. <a href="#scm">[ref]</a></td>
                        </tr>
                        <tr>
                            <th>tip</th>
                            <td>The tip revision (usually just called the tip) is the most recent changeset in the repository. The tip is
                                the most recently changed head. <a href="#tip">[ref]</a> </td>
                        </tr>
                        <tr>
                            <th>update</th>
                            <td>Update the repository's working directory (the "working copy") to the specified revision of the repository
                                or to the tip revision of the current (named) branch if no revision is specified. <a href="#update">[ref]</a> </td>
                        </tr>
                        <tr>
                            <th>user-data</th>
                            <td>In Mercurial it is usually source code</td>
                        </tr>
                        <tr>
                            <th>working directory</th>
                            <td>In Mercurial the working directory contains a snapshot of your project at a particular point in history.
                                It is the top-level directory in a repository, in which the plain versions of files are available to read,
                                edit and build. Files in the working directory are usually from the tip, but may be from older revisions,
                                or modified and not yet committed. It is sometimes called the “working copy”. <a href="#workingdirectory">[ref]</a></td>
                        </tr>
                    </tbody>
                </table>
            </aside>
            <aside class="bibliography">
                <h1>References </h1>
                <ul>
                    <li id="bib-mercurial">Mackall et al. <a href="http://mercurial.selenic.com/">Mercurial SCM </a>2011. </li>
                    <li id="merc_links"><a href="http://hgbook.red-bean.com/read/how-did-we-get-here.html">Mercurial book, motivation </a>, <a
                        href="http://hginit.com/">HgInit</a>—a Mercurial tutorial, <a href="http://mercurial.selenic.com/guide/">The Mercurial User's
                            Guide</a>, <a href="http://mercurial.selenic.com/wiki/">The Mercurial Wiki</a> </li>
                    <li id="posabook">Frank Buschmann, Regine Meunier, Hans Rohnert, and Peter Sommerlad.Pattern-Oriented Software Architecture Volume 1: A System
                        of Patterns. 1996. </li>
                    <li id="mercurial-book-4">Bryan O'Sullivan. Mercurial: The Definitive Guide. 2009. <a href="http://hgbook.red-bean.com/read/behind-the-scenes.html#x8-640004">
                        http://hgbook.red-bean.com/read/behind-the-scenes.html#x8-640004 </a></li>
                    <li id="aosabook">Amy Brown and Greg Wilson. The Architecture of Open Source Applications. 2011. <a href="http://www.aosabook.org/">
                        http://www.aosabook.org/</a> </li>
                    <li><a href="http://en.wikipedia.org/">Wikipedia</a> </li>
                    <li id="mercurial-arch">Mercurial Project Architecture. <a href="http://mercurial.selenic.com/wiki/WhatGoesWhere">http://mercurial.selenic.com/wiki/WhatGoesWhere</a>
                    </li>
                    <li id="Mercurial Interceptor diagram"> Interceptor Pattern. <a href="http://en.wikipedia.org/wiki/Interceptor_pattern">http://en.wikipedia.org/wiki/Interceptor_pattern</a>
                    </li>
                    <li id="mercurial-guide">Mercurial: The Definitive Guide by Bryan O'Sullivan <a href="http://http://hgbook.red-bean.com/read/collaborating-with-other-people.html">
                        http://http://hgbook.red-bean.com/read/collaborating-with-other-people.html</a> </li>
                    <li id="about-mercurial"><a href="http://mercurial.selenic.com/about/">About Mercurial: advantages of using Mercurial</a>
                    </li>
                    <li id="mercurial-dev-process"><a href="http://mercurial.selenic.com/wiki/MercurialDevelopmentProcess">Mercurial Wiki: Mercurial
                        Development Process.</a> </li>
                    <li id="system_overview_diagram_links"><a href="http://petevidler.com/2010/03/bite-sized-mercurial-intro/">Introduction to Bite-Sized
                        Mercurial</a></li>
                    <li id="key_drivers"><a href="http://mercurial.selenic.com/about/">About Mercurial: advantages of using Mercurial</a> </li>
                    <li id="bite_sized_mercurial"><a href="http://petevidler.com/2010/03/bite-sized-mercurial-intro/">Bite sized Mercurial introduction</a>
                    </li>
                    <li id="intro_to_DVCS"><a href="http://betterexplained.com/articles/intro-to-distributed-version-control-illustrated/">Introduction
                        to distributed version control</a> </li>
                    <li id="merc_repositories"><a href="http://mercurial.selenic.com/wiki/PublishingRepositories">Mercurial: Publishing Repositories</a>
                    </li>
                    <li id="remote_proxy"><a href="http://www.cs.ucsb.edu/~cappello/50/resources/patterns/RemoteProxy.shtml">Remote proxy</a>
                    </li>
                    <li id="POSA2">Douglas Schmidt, Michael Stal, Hans Rohnert and Frank Buschmann Pattern-Oriented Software Architecture, Patterns for Concurrent and Networked Objects, Volume 2</li>
                    <li id="bib-idapo">Stol, K.J. and Avgeriou, P. and Ali Babar, M. Design and evaluation of a process for identifying architecture patterns in open source software.
                     In <i>Software Architecture</i>, pages 147&ndash;163. Springer, 2011</li>
                     <li id="bib-harrison2010pattern">Harrison, N. and Avgeriou, P. Pattern-based architecture reviews. In <i>IEEE Software</i>. IEEE, 2010</li>
                     <li id="security">Markus Schumacher, Eduardo Fernandez, Duane Hybertson, and Frank Buschmann.
                     Security Patterns: Integrating Security and Systems Engineering. John Wiley & Sons, 2005</li>

                    <li id="changelog"><a href="http://mercurial.selenic.com/wiki/Changelog">Mercurial changelog</a></li>
                    <li id="changeset"><a href="http://mercurial.selenic.com/wiki/ChangeSet">Mercurial changeset</a></li>
                    <li id="cloning"><a href="http://mercurial.selenic.com/wiki/Clone">Mercurial cloning</a></li>

                    <li id="commit"><a href="http://mercurial.selenic.com/wiki/Commit">Mercurial commit</a></li>
                    <li id="conflict"><a href="http://mercurial.selenic.com/wiki/Conflict">Mercurial conflict</a></li>
                    <li id="diff"><a href="http://mercurial.selenic.com/wiki/Diff">Mercurial diff</a></li>
                    <li id="dirstate"><a href="http://mercurial.selenic.com/wiki/DirState">Mercurial dirstate</a></li>
                    <li id="filelog"><a href="http://hgbook.red-bean.com/read/behind-the-scenes.html">Mercurial filelog</a></li>
                    <li id="head"><a href="http://mercurial.selenic.com/wiki/Head">Mercurial head</a></li>
                    <li id="hook"><a href="http://mercurial.selenic.com/wiki/Hook">Mercurial hook</a></li>
                    <li id="manifest"><a href="http://mercurial.selenic.com/wiki/Manifest">Mercurial manifest</a></li>
                    <li id="merge"><a href="http://mercurial.selenic.com/wiki/Merge">Mercurial merge</a></li>
                    <li id="parent"><a href="http://mercurial.selenic.com/wiki/Parent">Mercurial parent</a></li>
                    <li id="pull"><a href="http://mercurial.selenic.com/wiki/Pull">Mercurial pull</a></li>
                    <li id="push"><a href="http://mercurial.selenic.com/wiki/Push">Mercurial push</a></li>
                    <li id="repository"><a href="http://mercurial.selenic.com/wiki/Repository">Mercurial repository</a></li>
                    <li id="revision"><a href="http://mercurial.selenic.com/wiki/Revision">Mercurial revision</a></li>
                    <li id="bib-hg-wiki-revlog">Buehlmann, A. et al. <a href="http://mercurial.selenic.com/wiki/Revlog">Revlog</a>. In <i><a href="http://mercurial.selenic.com/wiki/Mercurial">Mercurial wiki</a></i>, Last update 2011-02-25.</li>
                    <li id="scm"><a href="http://mercurial.selenic.com/wiki/SCM">Mercurial SCM</a></li>
                    <li id="tip"><a href="http://mercurial.selenic.com/wiki/Tip">Mercurial tip</a></li>
                    <li id="update"><a href="http://mercurial.selenic.com/wiki/Update">Mercurial update</a></li>
                    <li id="workingdirectory"><a href="http://mercurial.selenic.com/wiki/WorkingDirectory">Mercurial working directory</a></li>
                    <li id="matt_mackall"><a href="http://mercurial.selenic.com/wiki/mpm">Matt Mackall</a></li>
                    <li id="community"><a href="http://mercurial.selenic.com/wiki/DeveloperInfo#Working_with_the_community">Mercurial community</a></li>
                    <li id="mailinglist"><a href="http://mercurial.selenic.com/wiki/MailingLists">Mercurial mailinglists</a></li>
                    <li id="irc"><a href="http://mercurial.selenic.com/wiki/IRC">Mercurial IRC</a></li>
                    <li id="bib-hg-lkml-announcement">Mackall, M. <a href="http://lkml.indiana.edu/hypermail/linux/kernel/0504.2/0670.html">Mercurial v0.1 - a minimal scalable distributed SCM</a>. On the <i>Linux Kernel Mailing List</i>, April 19, 2005</li>
                    <li id="bib-mackall2006betterscm">Mackall, M. <a href="http://mercurial.selenic.com/wiki/Presentations?action=AttachFile&do=get&target=ols-mercurial-paper.pdf">Towards a Better SCM: Revlog and Mercurial</a>. 2006</li>
                </ul>
            </aside>
        </article>
    </div>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="generateTOC.js"></script>
</body>
</html>
